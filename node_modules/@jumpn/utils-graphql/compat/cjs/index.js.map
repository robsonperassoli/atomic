{"version":3,"file":"index.js","sources":["../../src/errorsToString.js","../../src/getOperationType.js","../../src/hasSubscription.js","../../src/requestFromCompat.js","../../src/requestToCompat.js"],"sourcesContent":["// @flow\n\nimport type {GqlError} from \"./types\";\n\nconst locationsToString = locations =>\n  locations.map(({column, line}) => `${line}:${column}`).join(\"; \");\n\nconst errorToString = ({message, locations}) =>\n  message + (locations ? ` (${locationsToString(locations)})` : \"\");\n\n/**\n * Transforms an array of GqlError into a string.\n *\n * @example\n *\n * const gqlRespose = {\n *   errors: [\n *     {message: \"First Error\", locations: [{column: 10, line: 2}]},\n *     {message: \"Second Error\", locations: [{column: 2, line: 4}]}\n *   ]\n * }\n *\n * const error = errorsToString(gqlRespose.errors);\n * // string with the following:\n * // First Error (2:10)\n * // Second Error (4:2)\n */\nconst errorsToString = (gqlErrors: Array<GqlError>): string =>\n  gqlErrors.map(errorToString).join(\"\\n\");\n\nexport default errorsToString;\n","// @flow\n\nimport type {GqlOperationType} from \"./types\";\n\nconst operationTypeRe = /^\\s*(query|mutation|subscription|\\{)/;\n\nconst getOperationTypeFromMatched = (matched: string): GqlOperationType =>\n  matched === \"{\" ? \"query\" : (matched: any);\n\n/**\n * Returns the type (query, mutation, or subscription) of the given operation\n *\n * @example\n *\n * const operation = `\n *   subscription userSubscription($userId: ID!) {\n *     user(userId: $userId) {\n *       id\n *       name\n *     }\n *   }\n * `;\n *\n * const operationType = getOperationType(operation);\n *\n * console.log(operationType); // \"subscription\"\n */\nconst getOperationType = (operation: string): GqlOperationType => {\n  const result = operation.match(operationTypeRe);\n\n  if (!result) {\n    throw new TypeError(`Invalid operation:\\n${operation}`);\n  }\n\n  return getOperationTypeFromMatched(result[1]);\n};\n\nexport default getOperationType;\n","// @flow\n\nimport type {DocumentNode} from \"graphql/language/ast\";\n\nconst isSubscription = definition =>\n  definition.kind === \"OperationDefinition\" &&\n  definition.operation === \"subscription\";\n\n/**\n * Returns true if documentNode has a subscription or false otherwise\n */\nconst hasSubscription = (documentNode: DocumentNode): boolean =>\n  documentNode.definitions.some(isSubscription);\n\nexport default hasSubscription;\n","// @flow\n\nimport type {GqlRequest, GqlRequestCompat} from \"./types\";\n\n/**\n * Creates a GqlRequest using given GqlRequestCompat\n *\n * @param {GqlRequestCompat<Variables>} gqlRequestCompat\n *\n * @return {GqlRequest<Variables>} \n *\n * @example\n * const query = `\n *   query userQuery($userId: ID!) {\n *     user(userId: $userId) {\n *       id\n *       email\n *     }\n *   }\n * `;\n * \n * console.log(requestFromCompat({query, variables: {userId: 10}}));\n * // {operation: \"...\", variables: {userId: 10}}\n */\nconst requestFromCompat = <Variables: void | Object>({\n  query: operation,\n  variables\n}: GqlRequestCompat<Variables>): GqlRequest<Variables> =>\n  variables ? {operation, variables} : {operation};\n\nexport default requestFromCompat;\n","// @flow\n\nimport type {GqlRequest, GqlRequestCompat} from \"./types\";\n\n/**\n * Creates a GqlRequest using given GqlRequestCompat\n *\n * @param {GqlRequest<Variables>} gqlRequest\n *\n * @return {GqlRequestCompat<Variables>}\n * \n * @example\n * const operation = `\n *   query userQuery($userId: ID!) {\n *     user(userId: $userId) {\n *       id\n *       email\n *     }\n *   }\n * `;\n * \n * console.log(requestToCompat({operation, variables: {userId: 10}}));\n * // {query: \"...\", variables: {userId: 10}}\n */\nconst requestToCompat = <Variables: void | Object>({\n  operation: query,\n  variables\n}: GqlRequest<Variables>): GqlRequestCompat<Variables> =>\n  variables ? {query, variables} : {query};\n\nexport default requestToCompat;\n"],"names":["locationsToString","locations","map","column","line","join","errorToString","message","errorsToString","gqlErrors","operationTypeRe","getOperationTypeFromMatched","matched","getOperationType","operation","result","match","TypeError","isSubscription","definition","kind","hasSubscription","documentNode","definitions","some","requestFromCompat","query","variables","requestToCompat"],"mappings":";;;;;;;;;;;;;;AAIA,IAAMA,iBAAiB,GAAG,2BAAAC,SAAS;;;;;SACjCA,SAAS,CAACC,GAAV,CAAc;QAAEC,MAAF,QAAEA,MAAF;QAAUC,IAAV,QAAUA,IAAV;;;;qBAAuBA,IAAvB,cAA+BD,MAA/B;GAAd,aAAuDE,IAAvD,CAA4D,IAA5D,CADiC;CAAZ,gBAAvB;;AAGA,IAAMC,aAAa,GAAG;MAAEC,OAAF,SAAEA,OAAF;MAAWN,SAAX,SAAWA,SAAX;;;;SACpBM,OAAO,IAAIN,SAAS,eAAQD,iBAAiB,CAACC,SAAD,CAAzB,SAA0C,EAAvD,CADa;CAAH,gBAAnB;;;;;;;;;;;;;;;;;;;;AAoBA,IAAMO,cAAc,GAAG,wBAACC,SAAD;;;SACrBA,SAAS,CAACP,GAAV,CAAcI,aAAd,EAA6BD,IAA7B,CAAkC,IAAlC,CADqB;CAAH,gBAApB;;;;ACvBA,IAAMK,eAAe,GAAG,sCAAxB;;AAEA,IAAMC,2BAA2B,GAAG,qCAACC,OAAD;;;SAClCA,OAAO,KAAK,GAAZ,GAAkB,OAAlB,GAA6BA,OADK;CAAH,gBAAjC;;;;;;;;;;;;;;;;;;;;;AAqBA,IAAMC,gBAAgB,GAAG,0BAACC,SAAD,EAAyC;;;MAC1DC,MAAM,GAAGD,SAAS,CAACE,KAAV,CAAgBN,eAAhB,CAAf;;MAEI,CAACK,MAAL,EAAa;UACL,IAAIE,SAAJ,+BAAqCH,SAArC,EAAN;;;SAGKH,2BAA2B,CAACI,MAAM,CAAC,CAAD,CAAP,CAAlC;CAPoB,gBAAtB;;;;ACvBA,IAAMG,cAAc,GAAG,wBAAAC,UAAU;;;SAC/BA,UAAU,CAACC,IAAX,KAAoB,qBAApB,IACAD,UAAU,CAACL,SAAX,KAAyB,cAFM;CAAb,gBAApB;;;;;;AAOA,IAAMO,eAAe,GAAG,yBAACC,YAAD;;;SACtBA,YAAY,CAACC,WAAb,CAAyBC,IAAzB,CAA8BN,cAA9B,CADsB;CAAH,gBAArB;;;;;;;;;;;;;;;;;;;;;;;;ACaA,IAAMO,iBAAiB,GAAG;MACjBX,SADiB,QACxBY,KADwB;MAExBC,SAFwB,QAExBA,SAFwB;;;;SAIxBA,SAAS,GAAG;IAACb,SAAS,EAATA,SAAD;IAAYa,SAAS,EAATA;GAAf,GAA4B;IAACb,SAAS,EAATA;GAJd;CAAH,gBAAvB;;;;;;;;;;;;;;;;;;;;;;;;ACAA,IAAMc,eAAe,GAAG;MACXF,KADW,QACtBZ,SADsB;MAEtBa,SAFsB,QAEtBA,SAFsB;;;;SAItBA,SAAS,GAAG;IAACD,KAAK,EAALA,KAAD;IAAQC,SAAS,EAATA;GAAX,GAAwB;IAACD,KAAK,EAALA;GAJZ;CAAH,gBAArB;;;;;;;;"}
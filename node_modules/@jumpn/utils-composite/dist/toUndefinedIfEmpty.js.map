{"version":3,"file":"toUndefinedIfEmpty.js","sources":["../src/getKeys.js","../src/isEmpty.js","../src/toUndefinedIfEmpty.js"],"sourcesContent":["// @flow\n\nimport type {Composite, Key} from \"./types\";\n\n/**\n * Get own enumerable keys.\n */\nconst getKeys = (composite: Composite): Array<Key> =>\n  Array.isArray(composite) ? [...composite.keys()] : Object.keys(composite);\n\nexport default getKeys;\n","// @flow\n\nimport getKeys from \"./getKeys\";\n\nimport type {Composite} from \"./types\";\n\n/**\n * Returns true if composite has no own enumerable keys (is empty) or false\n * otherwise\n */\nconst isEmpty = (composite: Composite): boolean =>\n  getKeys(composite).length === 0;\n\nexport default isEmpty;\n","// @flow\n\nimport isEmpty from \"./isEmpty\";\n\nimport type {Composite} from \"./types\";\n\n/**\n * Returns given composite if it has any own enumerable keys (is not empty) or\n * undefined otherwise\n *\n * @param {Composite} composite\n * \n * @returns {Composite}\n */\nconst toUndefinedIfEmpty = <C: Composite>(composite: C): void | C =>\n  isEmpty(composite) ? undefined : composite;\n\nexport default toUndefinedIfEmpty;\n"],"names":["getKeys","composite","Array","isArray","keys","_Object$keys","isEmpty","length","toUndefinedIfEmpty","undefined"],"mappings":"uNAOMA,QAAU,SAACC,uCACfC,MAAMC,QAAQF,gCAAiBA,EAAUG,SAAUC,aAAYJ,gCCE3DK,QAAU,SAACL,uCACe,IAA9BD,QAAQC,GAAWM,kCCGfC,mBAAqB,SAAeP,qCACxCK,QAAQL,QAAaQ,EAAYR"}
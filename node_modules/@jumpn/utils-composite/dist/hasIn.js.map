{"version":3,"file":"hasIn.js","sources":["../src/get.js","../src/is.js","../src/getIn.js","../src/hasIn.js"],"sourcesContent":["// @flow\n\nimport {curry} from \"flow-static-land/lib/Fun\";\n\nimport type {Composite, Key} from \"./types\";\n\n/**\n * Get property value of given key.\n */\nconst get = (key: Key, composite: Composite): any => composite[(key: any)];\n\nexport default curry(get);\n","// @flow\n\n// TODO: use @jumpn/utils-object {is} once it is available\nconst isObject = thing => thing !== null && typeof thing === \"object\";\n\n/**\n * Returns true if parameter is a Composite or false otherwise\n */\nconst is = (thing: mixed) => Array.isArray(thing) || isObject(thing);\n\nexport default is;\n","// @flow\n\nimport {curry} from \"flow-static-land/lib/Fun\";\nimport {isLastIndex} from \"@jumpn/utils-array\";\n\nimport get from \"./get\";\nimport isComposite from \"./is\";\n\nimport type {Composite, Path} from \"./types\";\n\nconst getInIfNeeded = (index, path, value) =>\n  isLastIndex(path, index) ? value : getInRecur(index + 1, path, value);\n\nconst getNotCompositeErrorMessage = (index, path, maybeComposite) =>\n  `Expected to find a composite at [${path.join(\", \")}][${index}], ` +\n  `but instead got: ${typeof maybeComposite}`;\n\nconst ensureIsComposite = (index, path, maybeComposite) => {\n  if (isComposite(maybeComposite)) return maybeComposite;\n\n  throw new Error(getNotCompositeErrorMessage(index, path, maybeComposite));\n};\n\nconst getInRecur = (index, path, maybeComposite) =>\n  maybeComposite === undefined\n    ? undefined\n    : getInIfNeeded(\n        index,\n        path,\n        get(path[index], ensureIsComposite(index, path, maybeComposite))\n      );\n\n/**\n * Returns value located at the given path or undefined otherwise.\n */\nconst getIn = (path: Path, composite: Composite): any =>\n  path.length === 0 ? undefined : getInRecur(0, path, composite);\n\nexport default curry(getIn);\n","// @flow\n\nimport isDeepEqual from \"fast-deep-equal\";\nimport {curry} from \"flow-static-land/lib/Fun\";\n\nimport getIn from \"./getIn\";\n\nimport type {Composite, Path} from \"./types\";\n\n/**\n * Returns true if value located at given path is deeply equal to the one\n * specified.\n */\nconst hasIn = (path: Path, value: mixed, composite: Composite): boolean =>\n  isDeepEqual(getIn(path, composite), value);\n\nexport default curry(hasIn);\n"],"names":["get","key","composite","curry","isObject","thing","is","Array","isArray","getInIfNeeded","index","path","value","isLastIndex","getInRecur","getNotCompositeErrorMessage","maybeComposite","join","ensureIsComposite","isComposite","Error","undefined","getIn","length","hasIn","isDeepEqual"],"mappings":"sQASMA,IAAM,SAACC,EAAUC,uCAA8BA,EAAWD,uBAEjDE,MAAMH,oBCRfI,SAAW,gDAAmB,OAAVC,GAAmC,qBAAVA,sBAAAA,kBAK7CC,GAAK,SAACD,uCAAiBE,MAAMC,QAAQH,IAAUD,SAASC,gCCExDI,cAAgB,SAACC,EAAOC,EAAMC,uCAClCC,YAAYF,EAAMD,GAASE,EAAQE,WAAWJ,EAAQ,EAAGC,EAAMC,iBAE3DG,4BAA8B,SAACL,EAAOC,EAAMK,uCAChD,2CAAoCL,EAAKM,KAAK,mBAAUP,oCAC7BM,sBAAAA,kBAEvBE,kBAAoB,SAACR,EAAOC,EAAMK,mCAClCG,GAAYH,GAAiB,OAAOA,QAElC,IAAII,MAAML,4BAA4BL,EAAOC,EAAMK,kBAGrDF,WAAa,SAACJ,EAAOC,EAAMK,4CACZK,IAAnBL,OACIK,EACAZ,cACEC,EACAC,EACAX,MAAIW,EAAKD,GAAQQ,kBAAkBR,EAAOC,EAAMK,mBAMlDM,MAAQ,SAACX,EAAYT,uCACT,IAAhBS,EAAKY,YAAeF,EAAYP,WAAW,EAAGH,EAAMT,yBAEvCC,MAAMmB,oBCzBfE,MAAQ,SAACb,EAAYC,EAAcV,qCACvCuB,YAAYH,QAAMX,EAAMT,GAAYU,yBAEvBT,MAAMqB"}
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Do = exports.equals = exports.alt = exports.chain = exports.of = exports.map = exports.pempty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.inj = inj;
exports.prj = prj;
exports.empty = empty;
exports.concat = concat;
exports.ap = ap;
exports.reduce = reduce;
exports.traverse = traverse;
exports.unfoldr = unfoldr;
exports.getSetoid = getSetoid;
exports.uncons = uncons;
exports.length = length;
exports.isEmpty = isEmpty;
exports.isOutOfBound = isOutOfBound;
exports.index = index;
exports.cons = cons;
exports.snoc = snoc;
exports.head = head;
exports.last = last;
exports.tail = tail;
exports.slice = slice;
exports.init = init;
exports.take = take;
exports.takeWhile = takeWhile;
exports.drop = drop;
exports.dropWhile = dropWhile;
exports.findIndex = findIndex;
exports.filter = filter;
exports.unsafeInsertAt = unsafeInsertAt;
exports.insertAt = insertAt;
exports.unsafeUpdateAt = unsafeUpdateAt;
exports.updateAt = updateAt;
exports.unsafeDeleteAt = unsafeDeleteAt;
exports.deleteAt = deleteAt;
exports.modifyAt = modifyAt;
exports.reverse = reverse;
exports.mapMaybe = mapMaybe;
exports.catMaybes = catMaybes;
exports.sort = sort;

var _HKT = require('./HKT');

var _Maybe = require('./Maybe');

var maybe = _interopRequireWildcard(_Maybe);

var _Identity = require('./Identity');

var _Ord = require('./Ord');

var _Tuple = require('./Tuple');

var tuple = _interopRequireWildcard(_Tuple);

var _Apply = require('./Apply');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IsArr = function IsArr() {
  _classCallCheck(this, IsArr);
};

function inj(a) {
  return a;
}

function prj(fa) {
  return fa;
}

function copy(as) {
  return prj(as).slice();
}

function empty() {
  return inj([]);
}

var pempty = exports.pempty = empty;

function concat(x, y) {
  return inj(prj(x).concat(prj(y)));
}

function _map(f, fa) {
  return inj(prj(fa).map(f));
}

exports.map = _map;
function ap(fab, fa) {
  var a = prj(fa);
  return inj(prj(fab).reduce(function (acc, f) {
    return acc.concat(a.map(f));
  }, []));
}

function _of(a) {
  return inj([a]);
}

exports.of = _of;
function _chain(f, fa) {
  return inj(prj(fa).reduce(function (acc, a) {
    return acc.concat(prj(f(a)));
  }, []));
}

exports.chain = _chain;
function reduce(f, b, fa) {
  return prj(fa).reduce(f, b);
}

function traverse(applicative, f, ta) {
  var snocA2 = (0, _Apply.liftA2)(applicative, snoc);
  return reduce(function (fab, a) {
    return snocA2(fab, f(a));
  }, applicative.of(empty()), ta);
}

function unfoldr(f, b) {
  var ret = [];
  var bb = b;
  while (true) {
    // eslint-disable-line no-constant-condition
    var mt = f(bb);
    if (maybe.isNothing(mt)) {
      break;
    }
    var t = maybe.fromJust(mt);
    ret.push(tuple.fst(t));
    bb = tuple.snd(t);
  }
  return inj(ret);
}

var alt = exports.alt = concat;

function _equals(setoid, fx, fy) {
  var x = prj(fx);
  var y = prj(fy);
  if (x.length !== y.length) {
    return false;
  }
  for (var i = 0, len = x.length; i < len; i++) {
    if (!setoid.equals(x[i], y[i])) {
      return false;
    }
  }
  return true;
}

exports.equals = _equals;
function getSetoid(setoid) {
  return {
    equals: function equals(fx, fy) {
      return _equals(setoid, fx, fy);
    }
  };
}

function uncons(as, empty, otherwise) {
  var xs = prj(as);
  return xs.length === 0 ? empty() : otherwise(xs[0], inj(xs.slice(1)));
}

function length(as) {
  return prj(as).length;
}

function isEmpty(as) {
  return length(as) === 0;
}

function isOutOfBound(i, as) {
  return i < 0 || i >= prj(as).length;
}

function index(as, i) {
  var xs = prj(as);
  return isOutOfBound(i, as) ? maybe.Nothing : maybe.of(xs[i]);
}

function cons(a, as) {
  return inj([a].concat(prj(as)));
}

function snoc(as, a) {
  return inj(prj(as).concat(a));
}

function head(as) {
  return isEmpty(as) ? maybe.Nothing : maybe.of(prj(as)[0]);
}

function last(as) {
  return index(as, length(as) - 1);
}

function tail(as) {
  var xs = prj(as);
  var len = xs.length;
  return len === 0 ? maybe.Nothing : maybe.of(inj(xs.slice(1)));
}

function slice(start, end, as) {
  return inj(prj(as).slice(start, end));
}

function init(as) {
  var xs = prj(as);
  var len = xs.length;
  return len === 0 ? maybe.Nothing : maybe.of(inj(xs.slice(0, len - 1)));
}

function take(n, as) {
  return slice(0, n, as);
}

function takeWhile(predicate, as) {
  return inj(prj(as).slice().filter(predicate));
}

function drop(n, as) {
  return slice(n, length(as), as);
}

function dropWhile(predicate, as) {
  return takeWhile(function (a) {
    return !predicate(a);
  }, as);
}

function findIndex(predicate, as) {
  var xs = prj(as);
  for (var i = 0, len = xs.length; i < len; i++) {
    if (predicate(xs[i])) {
      return maybe.of(i);
    }
  }
  return maybe.Nothing;
}

function filter(predicate, as) {
  return inj(prj(as).filter(predicate));
}

function unsafeInsertAt(i, a, as) {
  var xs = copy(as);
  xs.splice(i, 0, a);
  return inj(xs);
}

function insertAt(i, a, as) {
  return i < 0 || i > prj(as).length ? maybe.Nothing : maybe.of(unsafeInsertAt(i, a, as));
}

function unsafeUpdateAt(i, a, as) {
  var xs = copy(as);
  xs[i] = a;
  return inj(xs);
}

function updateAt(i, a, as) {
  return isOutOfBound(i, as) ? maybe.Nothing : maybe.of(unsafeUpdateAt(i, a, as));
}

function unsafeDeleteAt(i, as) {
  var xs = copy(as);
  xs.splice(i, 1);
  return inj(xs);
}

function deleteAt(i, as) {
  return isOutOfBound(i, as) ? maybe.Nothing : maybe.of(unsafeDeleteAt(i, as));
}

function modifyAt(i, f, as) {
  return isOutOfBound(i, as) ? maybe.Nothing : updateAt(i, f(prj(as)[i]), as);
}

function reverse(as) {
  return inj(copy(as).reverse());
}

function mapMaybe(f, as) {
  return _chain(function (a) {
    return maybe.maybe(empty(), _of, f(a));
  }, as);
}

function catMaybes(as) {
  return mapMaybe(_Identity.id, as);
}

function sort(ord, as) {
  return inj(copy(as).sort((0, _Ord.toNativeComparator)(ord.compare)));
}

var Do = exports.Do = function () {
  _createClass(Do, null, [{
    key: 'of',
    value: function of(a) {
      return new Do(_of(a));
    }
  }]);

  function Do(value) {
    _classCallCheck(this, Do);

    this.value = value;
  }

  _createClass(Do, [{
    key: 'map',
    value: function map(f) {
      return new Do(_map(f, this.value));
    }
  }, {
    key: 'chain',
    value: function chain(f) {
      return new Do(_chain(f, this.value));
    }
  }]);

  return Do;
}();

if (false) {
  // eslint-disable-line
  ({
    concat: concat,
    empty: empty,
    map: _map,
    ap: ap,
    of: _of,
    chain: _chain,
    reduce: reduce,
    alt: alt,
    pempty: pempty,
    traverse: traverse,
    unfoldr: unfoldr
  });
}
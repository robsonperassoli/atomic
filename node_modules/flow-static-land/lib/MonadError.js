'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.catchJust = catchJust;

var _HKT = require('./HKT');

var _Maybe = require('./Maybe');

var maybe = _interopRequireWildcard(_Maybe);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// This function allows you to provide a predicate for selecting the
// exceptions that you're interested in, and handle only those exceptons.
// If the inner computation throws an exception, and the predicate returns
// Nothing, then the whole computation will still fail with that exception.


// The `MonadError` type class represents those monads which support errors via
// `throwError` and `catchError`.
//
// - `throwError e` throws the error `e`
// - `catchError x f` calls the error handler `f` if an error is thrown during the
//   evaluation of `x`.
//
// An implementation is provided for `ErrorT`, and for other monad transformers
// defined in this library.
//
// Laws:
//
// - Left zero: `throwError e >>= f = throwError e`
// - Catch: `catchError (throwError e) f = f e`
// - Pure: `catchError (pure a) f = pure a`
//

function catchJust(monadError, predicate, ma, handler) {
  return monadError.catchError(ma, function (e) {
    var b = maybe.prj(predicate(e));
    return b == null ? monadError.throwError(e) : handler(b);
  });
}
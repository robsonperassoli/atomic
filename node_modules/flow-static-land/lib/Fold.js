'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fold = fold;
exports.getAll = getAll;
exports.find = find;
exports.headOption = headOption;
exports.exist = exist;
exports.all = all;
exports.choice = choice;
exports.composeFold = composeFold;
exports.fromFoldable = fromFoldable;

var _Monoid = require('./Monoid');

var _Identity = require('./Identity');

var _Maybe = require('./Maybe');

var maybe = _interopRequireWildcard(_Maybe);

var _Either = require('./Either');

var either = _interopRequireWildcard(_Either);

var _HKT = require('./HKT');

var _Foldable = require('./Foldable');

var foldable = _interopRequireWildcard(_Foldable);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/** combine all targets using a target's Monoid */
function fold(fold, monoid, s) {
  return fold.foldMap(monoid, _Identity.id, s);
}

/**
 * get all the targets of a [[Fold]]
 */

function getAll(fold, s) {
  return fold.foldMap(_Monoid.arrayMonoid, function (a) {
    return [a];
  }, s);
}

/** find the first target of a [[Fold]] matching the predicate  */
function find(fold, p, s) {
  return fold.foldMap(maybe.first, function (a) {
    return p(a) ? maybe.of(a) : maybe.Nothing;
  }, s);
}

/** get the first target of a [[Fold]] */
function headOption(fold, s) {
  return find(fold, function () {
    return true;
  }, s);
}

/** check if at least one target satisfies the predicate */
function exist(fold, p, s) {
  return fold.foldMap(_Monoid.any, p, s);
}

/** check if all targets satisfy the predicate */
function all(fold, p, s) {
  return fold.foldMap(_Monoid.all, p, s);
}

/** join two Fold with the same target */
function choice(fold1, fold2) {
  return {
    foldMap: function foldMap(monoid, f, s) {
      return either.either(function (s1) {
        return fold1.foldMap(monoid, f, s1);
      }, function (s2) {
        return fold2.foldMap(monoid, f, s2);
      }, s);
    }
  };
}

function composeFold(ab, sa) {
  return {
    foldMap: function foldMap(monoid, f, s) {
      return sa.foldMap(monoid, function (a) {
        return ab.foldMap(monoid, f, a);
      }, s);
    }
  };
}

function fromFoldable(fold) {
  return {
    foldMap: function foldMap(monoid, f, s) {
      return foldable.foldMap(fold, monoid, f, s);
    }
  };
}
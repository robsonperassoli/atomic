'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prj = prj;
exports.inj = inj;
exports.runAff = runAff;
exports.nonCanceler = nonCanceler;
exports.alwaysCanceler = alwaysCanceler;
exports.launchAff = launchAff;
exports.map = map;
exports.ap = ap;
exports.of = of;
exports.chain = chain;

var _HKT = require('./HKT');

var _Exception = require('./Exception');

var _Fun = require('./Fun');

var _Eff = require('./Eff');

var eff = _interopRequireWildcard(_Eff);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*

  Porting of purescript-aff https://github.com/slamdata/purescript-aff

*/

var IsAff = function IsAff() {
  _classCallCheck(this, IsAff);
};

// An asynchronous computation with effects `e`. The computation either
// errors or produces a value of type `a`.


// A pure asynchronous computation, having no effects other than
// asynchronous computation.


// A canceler is an asynchronous function that can be used to attempt the
// cancelation of a computation. Returns a boolean flag indicating whether
// or not the cancellation was successful. Many computations may be composite,
// in such cases the flag indicates whether any part of the computation was
// successfully canceled. The flag should not be used for communication.


function prj(aff) {
  return aff;
}

function inj(affv) {
  return affv;
}

// Runs the asynchronous computation. You must supply an error callback and a
// success callback.
function runAff(error, // <= do not use ErrorHandler type here
success, // <= do not use SuccessHandler type here
aff) {
  return eff.inj(function () {
    return prj(aff)(function (a) {
      eff.runEff(success(a));
    }, function (e) {
      eff.runEff(error(e));
    });
  });
}

// A constant canceler that always returns false.
function nonCanceler() {
  return (0, _Fun.constant)(of(false));
}

// A constant canceller that always returns true.
function alwaysCanceler() {
  return (0, _Fun.constant)(of(true));
}

// Converts the asynchronous computation into a synchronous one. All values
// are ignored, and if the computation produces an error, it is thrown.
//
// Catching exceptions by using `catchException` with the resulting Eff
// computation is not recommended, as exceptions may end up being thrown
// asynchronously, in which case they cannot be caught.
//
// If you do need to handle exceptions, you can use `runAff` instead
function launchAff(aff) {
  return runAff(_Exception.throwException, (0, _Fun.constant)(eff.of(undefined)), aff);
}

function map(f, fa) {
  return inj(function (success, error) {
    return prj(fa)(function (a) {
      return success(f(a));
    }, error);
  });
}

function ap(fab, fa) {
  return chain(function (f) {
    return map(f, fa);
  }, fab); // <= derived
}

function of(a) {
  return inj(function (success) {
    success(a);
    return nonCanceler();
  });
}

function chain(f, fa) {
  return inj(function (success, error) {
    var isCanceled = false;
    var requestCancel = false;
    var onCanceler = function onCanceler(canceler) {}; // eslint-disable-line no-unused-vars
    var canceler2 = null;

    var canceler1 = prj(fa)(function (v) {
      if (requestCancel) {
        isCanceled = true;
      } else {
        canceler2 = prj(f(v))(success, error);
        onCanceler(canceler2);
      }
    }, error);

    return function (e) {
      return inj(function (s, f) {
        requestCancel = true;
        if (canceler2 != null) {
          return prj(canceler2(e))(s, f);
        } else {
          return prj(canceler1(e))(function (bool) {
            if (bool || isCanceled) {
              s(true);
            } else {
              onCanceler = function onCanceler(canceler) {
                prj(canceler(e))(s, f);
              };
            }
          }, f);
        }
      });
    };
  });
}

if (false) {
  // eslint-disable-line
  ({
    map: map,
    ap: ap,
    of: of,
    chain: chain
  });
}
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Do = exports.toNothing = exports.first = exports.equals = exports.Nothing = exports.chain = exports.of = exports.map = exports.pempty = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.inj = inj;
exports.prj = prj;
exports.isNothing = isNothing;
exports.isJust = isJust;
exports.empty = empty;
exports.concat = concat;
exports.getSemigroup = getSemigroup;
exports.getMonoid = getMonoid;
exports.ap = ap;
exports.reduce = reduce;
exports.alt = alt;
exports.extend = extend;
exports.traverse = traverse;
exports.throwError = throwError;
exports.catchError = catchError;
exports.getSetoid = getSetoid;
exports.maybe = maybe;
exports.fromMaybe = fromMaybe;
exports.fromJust = fromJust;

var _HKT = require('./HKT');

var _Identity = require('./Identity');

var _Fun = require('./Fun');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IsMaybe = function IsMaybe() {
  _classCallCheck(this, IsMaybe);
};

function inj(a) {
  return a;
}

function prj(fa) {
  return fa;
}

function isNothing(x) {
  return x == Nothing;
}

function isJust(x) {
  return x != Nothing;
}

function empty() {
  return Nothing;
}

var pempty = exports.pempty = empty;

function concat(semigroup) {
  return function concat(fx, fy) {
    var x = prj(fx);
    var y = prj(fy);
    if (x == null) {
      return fy;
    }
    if (y == null) {
      return fx;
    }
    return _of(semigroup.concat(x, y));
  };
}

function getSemigroup(semigroup) {
  return {
    concat: concat(semigroup)
  };
}

function getMonoid(semigroup) {
  return {
    empty: empty,
    concat: concat(semigroup)
  };
}

function _map(f, fa) {
  var a = prj(fa);
  return a == null ? Nothing : inj(f(a));
}

exports.map = _map;
function ap(fab, fa) {
  var ab = prj(fab);
  return ab == null ? Nothing : _map(ab, fa);
}

function _of(a) {
  return inj(a);
}

exports.of = _of;
function _chain(f, fa) {
  return maybe(Nothing, f, fa);
}

exports.chain = _chain;
var Nothing = exports.Nothing = inj(null);

function reduce(f, b, fa) {
  var a = prj(fa);
  return a == null ? b : f(b, a);
}

function alt(fx, fy) {
  return fx == Nothing ? fy : fx;
}

function extend(f, ea) {
  return isNothing(ea) ? Nothing : inj(f(ea));
}

function _equals(setoid, fx, fy) {
  var x = prj(fx);
  var y = prj(fy);
  if (x == null || y == null) {
    return true;
  }
  if (x != null || y != null) {
    return setoid.equals(x, y);
  }
  return false;
}

exports.equals = _equals;
function traverse(applicative, f, ta) {
  var a = prj(ta);
  if (a == null) {
    return applicative.of(Nothing);
  }
  return applicative.map(_of, f(a));
}

function throwError(e) {
  // eslint-disable-line no-unused-vars
  return Nothing;
}

function catchError(ma, handler) {
  var a = prj(ma);
  return a == null ? handler() : ma;
}

function getSetoid(setoid) {
  return {
    equals: function equals(fx, fy) {
      return _equals(setoid, fx, fy);
    }
  };
}

function maybe(b, f, fa) {
  return reduce(function (_, a) {
    return f(a);
  }, b, fa);
}

function fromMaybe(a, fa) {
  return maybe(a, _Identity.id, fa);
}

function fromJust(fa) {
  var a = prj(fa);
  if (a == null) {
    throw new Error('fromJust returned a Nothing');
  }
  return a;
}

// Maybe monoid returning the leftmost non-Nothing value.
var first = exports.first = {
  empty: empty,
  concat: alt
};

var toNothing = exports.toNothing = (0, _Fun.constant)(maybe.Nothing);

/*

  Do notation (experimental)

  Example:

  import * as maybe from '../Maybe'

  const x: Maybe<number> = maybe.Do.of(3)
    .map(n => n * 2)
    .chain(n => maybe.of(n - 1))
    .value

*/

var Do = exports.Do = function () {
  _createClass(Do, null, [{
    key: 'of',
    value: function of(a) {
      return new Do(_of(a));
    }
  }]);

  function Do(value) {
    _classCallCheck(this, Do);

    this.value = value;
  }

  _createClass(Do, [{
    key: 'map',
    value: function map(f) {
      return new Do(_map(f, this.value));
    }
  }, {
    key: 'chain',
    value: function chain(f) {
      return new Do(_chain(f, this.value));
    }
  }]);

  return Do;
}();

if (false) {
  // eslint-disable-line
  ({
    map: _map,
    ap: ap,
    of: _of,
    chain: _chain,
    reduce: reduce,
    alt: alt,
    pempty: pempty,
    extend: extend,
    traverse: traverse,
    throwError: throwError,
    catchError: catchError
  });
}